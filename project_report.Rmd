---
title: "Project Report"
author: "Surya Vishnubhatt"
date: "`r Sys.Date()`"
output: 
  html_document:
    fig_caption: yes
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libs, message=FALSE, echo=FALSE}
library(ggplot2)
library(tidyverse)
library(DESeq2)
library(vsn)
library(magrittr)
library(pheatmap)
library(EnhancedVolcano)
library(clusterProfiler)
library(org.Hs.eg.db) 
```

# Introduction

Alzheimer's disease (AD) is the most common cause of dementia, it is a devastating neurodegenerative disorder that affects millions of people worldwide, contributing to roughly 60-70% of dementia cases [1]. The presenilin 1 (PSEN1) gene, which encodes a component of the γ-secretase complex involved in the processing of the amyloid precursor protein (APP), is known to be linked to familial AD (fAD) [2,3]. Several mutations in the PSEN1 gene have been identified in fAD patients, including the A79V mutation. The specific impact of the A79V mutation on gene expression in neuronal cells, however, is not well understood. A recent study by Corsi et al. investigated the A79V PSEN1 mutation in a 48 year old female patient [4]. This project aims to investigate the hypothesis that the A79V mutation in PSEN1 leads to changes in mRNA expression levels in neuronal cells, specifically in coding genes associated with ECM components that are associated with neuron morphology, structural integrity, and plasticity. This project utilizes data obtained from the Corsi et al. study which are glutamatergic cortical neurons derived from fAD-mutant human induced pluripotent stem cells and their individual isogenic controls generated by CRISPR/Cas9 genome editing [4]. 

# Results

Throughout the course of this project, several key results were found. First, after performing Differential Gene Expression Analysis, it was found that the top 6 most differentially expressed genes were FRZB, CFH, NID2, CHCHD2, XIST, and ITGA8. Of these genes the most viable candidates were found to be CHCHD2 (Mitochondrial Nuclear Retrograde Regulator 1), XIST (X-inactive specific transcript), and ITGA8 (important in cytoskeletal organization and cellular adhesion) which were also found in the Corsi et al. study. Performing `plotCounts` analysis (refer Figure 9), we can see that CHCHD2 and XIST are expressed in the diseased state whilst ITGA8 is downregulated in the diseased state. This makes sense because a decrease in cytoskeletal organization and cellular adhesion (from ITGA8) is seen in Alzheimer’s due to neuronal degradation. Furthermore, Mitochondrial Nuclear Retrograde Regulator 1 (CHCHD2)  is involved in importing mitochondrial proteins as well as metabolism. This is most likely an indicator of neuronal mitochondrial dysfunction which is highly linked to neurodegenerative disease[5]. Finally, the XIST gene plays a major role in X chromosome inactivation which has been noted to correlate with Alzheimer’s disease as well [6]. As a further note, Corsi et al. found that, after performing L150P PSEN1 mutations in a male patient, that XIST was notably unique to the female result. However due to an insufficient sample size and lack of variety of diverse biological replicates, it is not possible to draw any firm conclusions. Furthermore, the results of the heatmaps in Figures 10 and 11 serve to display many significant differentially expressed genes wherein Figure 10 shows that there are many genes that exhibit low p values and Figure 11 shows how the differences in colors between the healthy and diseased seem to indicate a large amount of differentially expressed genes. The MA plot in Figure 12 serves to enhance this idea as we see many differentially expressed genes. The volcano plot in Figure 13 shows this as well with the genes of highest interest existing in the top left/right of the plot. Finally, as in Figure 14, PCA is performed and we see that the result of PC1 is 88% variance and the result of PC2 is 10% variance. As PC1 accounts for most of the variation, we can conclude that the main source of variation in the data is driven by differences between the two groups (i.e. differential gene expression), and there are likely no other large sources of variation that differentiate the groups beyond this main difference. Additionally, looking at the results of GO enrichment, we can see that the pathways yielded in all three categories (Biological Process (BP), Molecular Function (MF) and Cellular Components  (CC)) were predominantly related to the extracellular matrix organization and structure like “extracellular matrix organization”, “collagen-containing extracellular matrix”, and “extracellular matrix structural constituent” to name a few. This seems to prove the hypothesis that the A79V mutation in PSEN1 leads to changes in expression for coding genes associated with ECM components. Refer to the end of the Methods section for Enrichment Pathway Results.

Currently, the analysis is limited due to the constraints of the data as it is only 10 samples from one female patient. Due to the absence of any additional sequencing data, the conclusions drawn may not be representative. To overcome these limitations, a variety of PSEN1 mutations from a number of sources, with sufficient variation in biological replicates, could be integrated into a pipeline for comparison to yield more definitive results. Additionally, instead of just using GO enrichment, KEGG enrichment could have also been used to corroborate the results obtained to gain greater insight into the potential pathways yielded. 


# Methods

##### *Note for Parts I-IV Refer to the `project_scripts` Folder in Github for Fully Implementable Bash Scripts*

### I. Performing Data Download and Setting Up Hg38 Index

I used the ENA accession to identify all A79V mutated data. From this, I could see that the required accession numbers which spanned from SRR21190766 through SRR21190775 contained the pertinent mRNA data. This means that there are 10 files that I will be analyzing. Using the SRA Run Selector from NCBI, I found that SRR21190766-SRR21190770 contained the isogenic control (i.e. healthy) samples and that SRR21190771-SRR21190775 contain the diseased/mutated A79V samples. One of the key issues with the data was that, using ENA accession, only one "interleaved" file was given, to solve this, I used `fastq-dump` to download all files. The files are downloaded into their own unique folder titled with SRA accession number:

```{data_download}
#The range of A79V polyA data had to be found manually using ERA
#Range: SRR21190766 --> SRR21190775
start=21190766 
end=21190775

# Loop through each SRA accession number in the range
for ((i=start;i<=end;i++))
do
    # Define the SRA accession number
    accession="SRR${i}"
    echo "Now Processing -->" $accession
    # Create a folder with the accession number if it doesn't already exist
    if [ ! -d "$accession" ]
    then
        mkdir "$accession"
    fi

    # Run fastq-dump on the accession number and put the output in the folder with the same name
    fastq-dump --split-files "$accession" -O "$accession"
```

Now, I will need to build a new index. As I am using human genomic data, I downloaded the hg38 genome from the UCSC Genome Browser (via `wget ftp://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/hg38.fa.gz`), I then needed to obtain the corresponding `gtf` file. This was done by using the corresponding NCBI RefSeq gtf file provided by UCSC: `wget ftp://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/genes/hg38.ncbiRefSeq.gtf.gz` . After obtaining and unpacking these files, I then proceeded to build a new index of the hg38 human genome using `STAR`. 

```{hg38 indexing}
STAR --runMode genomeGenerate \
  --runThreadN 1 \
  --genomeDir hg38_indexed \
  --genomeFastaFiles /athena/angsd/scratch/spv4002/hg38/hg38.fa \
  --sjdbGTFfile /athena/angsd/scratch/spv4002/hg38/hg38.ncbiRefSeq.gtf \
  --sjdbOverhang 49

```

### II. Performing Quality Control

`FastQC` was performed on all my files to obtain an overview of errors associated with my `fastq` files:

```{fastqc}
# Loop over each directory in the list and run FastQC on the paired-end data
for i in {66..75}; do
  dir="SRR211907$i"
  
  # Create a subdirectory to store the FastQC results for each input directory
  mkdir fastqc_results/${dir}
  
  # Run FastQC on the paired-end data in the directory
  fastqc ${dir}/${dir}_1.fastq ${dir}/${dir}_2.fastq -o fastqc_results/${dir}
done
```

The results of the `FastQC` can be viewed in my Github page. The results of the `FastQC` yielded no errors to be concerned with regarding downstream analysis and the sequences flagged as poor quality remained at a value of zero for all files. This shows that the data obtained is of good quality. Some slight issues that I was concerned about regarded the Per base sequence content, Per sequence GC content, and Sequence Duplication Levels as many of the resulting files had `FastQC` results which marked these three categories as unusual/poor. However, this is actually to be expected with RNA-seq data due to steps taken in library preparation. 

Moving on, I then proceeded to perform a `MultiQC` on all my `FastQC` obtained data:

```{multiqc}
mamba activate multiqc
multiqc fastqc_results/SRR211907*/*_fastqc.zip -n multiqc_results
```

The results of this file can also be viewed on my Github submission. As expected (because `multiqc` is an aggregation of multiple `fastqc` files) we see that issues are noted in the same categories as above (Per base sequence content, Per sequence GC content, and Sequence Duplication Levels). However, for all other categories, we see stellar results regarding Sequence Quality, Per Sequence Quality, etc. Figure 1 shows the overall MultiQC Results. 

```{r fig1, fig.cap = "**Figure 1:** *MultiQC Results*", fig.align = "center", echo = FALSE}
knitr::include_graphics("~/Desktop/multiqc_results.png")
```
### III. Performing STAR Alignment and Indexing 

To perform STAR Alignment and Indexing, I iterate through all my `fastq` files and perform alignments to my reference genome (defined above). To perform alignment, the `--runMode` is set to `alignReads` and to perform indexing, `samtools` is used with the parameter `index` to align the newly created `.bam` file. 

```{align_index}
# Set the path to the reference genome index
REF=/athena/angsd/scratch/spv4002/hg38/hg38_indexed

# Set the range of A79V polyA data
start=21190766 
end=21190775

# Loop through each SRA accession number in the range
for ((i=start;i<=end;i++))
do
    # Define the SRA accession number
    accession="SRR${i}"
    # Run STAR to align the paired-end reads to the reference genome
    STAR --runMode alignReads\
        --runThreadN 4 \
        --genomeDir "$REF" \
        --readFilesIn "$accession/${accession}_1.fastq" "$accession/${accession}_2.fastq" \
        --outFileNamePrefix "${accession}/${accession}." \
        --outSAMtype BAM SortedByCoordinate  ;

    samtools index /athena/angsd/scratch/spv4002/${accession}/${accession}.Aligned.sortedByCoord.out.bam 
done
```

### IV. BamQC, AlignmentQC, featureCounts, and Mamba Environments

First, to perform quality analysis of the generated `.bam` files, I perform `BamQC`. To use it I routed the directory in which I needed to access it, iterated through all newly generated `.bam` files in my workspace and wrote the results out to an appropriately named file. 

```{bamqc}
for i in SRR*; do
    /softlib/apps/EL7/BamQC/bin/bamqc $i/*.bam -o bamqc_results
done
```

The results of the `BamQC` show that genome coverage, chromosome read density, soft clip length distributions, indel frequencies, and mapping quality distribution appear to be optimal. Additionally, there appears to be a high percent of primary alignments in all QC results. The only notable issue is in the insert length distribution for all files as there appears to be an outlier surpassing inferred insert length 93990. However, this is likely due to the fact that the data is stranded and its preparation may influence the presence of this outlier. Overall, the alignment results seem to be ready for downstream analysis. 

Moving on, AlignmentQC will be performed through `qorts` by accessing my data files. The code works by creating output directories first, then iterating through all the folders where my `.bam` files are contained and running `qorts` on each of them, and outputting them to their respective output directory. I use `generatePlots` to visualize the results and the `--stranded` parameter as the data is stranded. As `qorts` assumes paired-end by default, I will not have a parameter for it. 

```{qorts}
mamba activate qorts
# Create directories for each SRR ID
for index in {766..775}; do
  mkdir alignmentQC/SRR21190${index}_alignmentQC
done

# Run QoRTs on each bam file
for index in {766..775}; do
  bam_file=/athena/angsd/scratch/spv4002/SRR21190${index}/SRR21190${index}.Aligned.sortedByCoord.out.bam
  output_dir=/athena/angsd/scratch/spv4002/alignmentQC/SRR21190${index}_alignmentQC
  
  qorts -Xmx18000M QC \
  --generatePlots \
  --stranded \
  $bam_file \
  /athena/angsd/scratch/spv4002/hg38/hg38.ncbiRefSeq.gtf \
  $output_dir
done
```

After running `qorts` I could peruse the outputted `summary.txt` file and see that it completed successfully for all files. I can also see from the output of `qorts` that the Stranded_Rule_Code is equal to 1. This means that the data is `fr_firstStrand` which is equivalent to the stranded being reverse.


Using the results above, I know the parameters that need to be passed through `featureCounts`. I use the `-p` parameter as the data is paired end and the `-s 2` parameter as mentioned above to account for the reverse stranded nature of the data. I then write out the results to a file called `featureCounts.txt`. 

```{featureCounts}
featureCounts -p -s 2 --countReadPairs \
-a /athena/angsd/scratch/spv4002/hg38/hg38.ncbiRefSeq.gtf \
-o /athena/angsd/scratch/spv4002/featurecounts_result/featureCounts.txt \
/athena/angsd/scratch/spv4002/SRR21190766/SRR21190766.Aligned.sortedByCoord.out.bam /athena/angsd/scratch/spv4002/SRR21190767/SRR21190767.Aligned.sortedByCoord.out.bam /athena/angsd/scratch/spv4002/SRR21190768/SRR21190768.Aligned.sortedByCoord.out.bam /athena/angsd/scratch/spv4002/SRR21190769/SRR21190769.Aligned.sortedByCoord.out.bam /athena/angsd/scratch/spv4002/SRR21190770/SRR21190770.Aligned.sortedByCoord.out.bam /athena/angsd/scratch/spv4002/SRR21190771/SRR21190771.Aligned.sortedByCoord.out.bam /athena/angsd/scratch/spv4002/SRR21190772/SRR21190772.Aligned.sortedByCoord.out.bam /athena/angsd/scratch/spv4002/SRR21190773/SRR21190773.Aligned.sortedByCoord.out.bam /athena/angsd/scratch/spv4002/SRR21190774/SRR21190774.Aligned.sortedByCoord.out.bam /athena/angsd/scratch/spv4002/SRR21190775/SRR21190775.Aligned.sortedByCoord.out.bam
```

Now, the following displays the mamba environments that were used for this analysis from `mamba env list`:

```{results_mamba}
# conda environments:
angsd                 *  /athena/angsd/scratch/mef3005/share/envs/angsd
multiqc                  /athena/angsd/scratch/mef3005/share/envs/multiqc
qorts                    /athena/angsd/scratch/mef3005/share/envs/qorts
r42-deseq                /athena/angsd/scratch/mef3005/share/envs/r42-deseq
rseqc                    /athena/angsd/scratch/mef3005/share/envs/rseqc
trim-galore              /athena/angsd/scratch/mef3005/share/envs/trim-galore
base                     /pbtech_mounts/homes064/spv4002/mambaforge
```

Of these, only `angsd`, `multiqc`, and `qorts` were used for this project.

The following commands were used to generate the yaml files present in the github

```{generate_yaml}
mamba env export -n angsd --from-history > /athena/angsd/scratch/spv4002/mamba_env/angsd.min.yaml
mamba env export -n angsd > /athena/angsd/scratch/spv4002/mamba_env/angsd.full.yaml
mamba env export -n multiqc --from-history > /athena/angsd/scratch/spv4002/mamba_env/multiqc.min.yaml
mamba env export -n multiqc > /athena/angsd/scratch/spv4002/mamba_env/multiqc.full.yaml
mamba env export -n qorts --from-history > /athena/angsd/scratch/spv4002/mamba_env/qorts.min.yaml
mamba env export -n qorts > /athena/angsd/scratch/spv4002/mamba_env/qorts.full.yaml
```

### V. Preliminary Analysis of featureCounts Result

##### *Note for Parts V-IX: Check the actual project_report.Rmd Document for Full Code (as some portions have echo=FALSE) and Refer to Github file data_processing.Rmd within the folder RMD_Documents for More Information*

First, after performing an `scp` to get the featureCounts result to my local machine, I was able to visualize the results from featureCounts by plotting the Assigned vs. Unassigned ratios as can be seen in Figure 2. As one can see, the plot details how the bulk of reads are assigned and shows the data is ready for downstream analysis. Note that the data above is labeled according to if they are the isogenic control (healthy) or if they exhibit the A79V mutation (diseased). The integer values following each healthy and diseased value correspond to the last two digits of their SRA accession number as they all contain the same first 10 values (i.e. SRR211907__).


```{r fig2, fig.cap = "**Figure 2:** *Preliminary Analysis of featureCounts Result*", fig.align = "center"}
# Load required packages
library(ggplot2)
# Read in the summary files
fc_summary <- read.table("~/Desktop/featurecounts_result/featureCounts.txt.summary", header=TRUE, row.names=1)
# Subset the data to only include the desired rows
fc_summary_subset <- fc_summary[c("Assigned", "Unassigned_Ambiguity", "Unassigned_NoFeatures"),]
fc_summary_subset_t <- data.frame(t(fc_summary_subset))

class_samples <- rep(c(66:75), 3)
category <- c(rep("Assigned", 10), rep("Unassigned Ambiguity", 10), rep("Unassigned No Features", 10))

# Create a new data frame with the desired order of categories
data <- data.frame(
  Sample = ifelse(class_samples <= 70, paste0("healthy_", class_samples), paste0("diseased_", class_samples)),
  Category = category,
  Count = c(fc_summary_subset_t$Assigned, 
            fc_summary_subset_t$Unassigned_Ambiguity, 
            fc_summary_subset_t$Unassigned_NoFeatures)
)

# Plot the data using ggplot2
ggplot(data, aes(x = Sample, y = Count, fill = Category)) +
  geom_bar(stat = "identity", position = "dodge") +
  xlab("Sample") +
  ylab("Count") +
  ggtitle("Assigned and Unassigned Reads by Sample") +
  theme_bw() +
  coord_flip() #rotate 90 degrees
```

### VI. DESeq2 Object Setup

After performing this preliminary analysis, I loaded in the `featureCounts` table using `readcounts` and proceeded to manipulate the read count table. Such that it matches the parameters outlined above. I also made a few more tweaks such that gene IDs should be stored as row names and columns without read counts should be excluded. Finally, I created a new dataframe `sample_info` with the readcounts data to create the `colData` condition to keep track of the condition (healthy or diseased). 

```{r readcounts, results = "hide", echo=FALSE}
# Load the featureCounts output file
folder <- "~/Desktop/featurecounts_result/" # download count table!
readcounts <- read.table(paste0(folder, "featureCounts.txt"), header = TRUE)
str(readcounts)
orig_names <- names(readcounts) # keep a back-up copy of the original names

#Rename to disease condition followed by patient number (last two digits of accession no. SRR211907__)
names(readcounts) <- c(names(readcounts)[1:6],
paste("healthy", c(66:70), sep = "_"),
paste("diseased", c(71:75), sep = "_") ) # less potential for typos
names(readcounts)

## gene IDs should be stored as row.names
row.names(readcounts) <- make.names(readcounts$Geneid)
readcounts <- readcounts[ , -c(1:6)]

sample_info <- data.frame(condition = gsub("_[0-9]+", "", names(readcounts)),
row.names = names(readcounts) )
```

This data frame can then be used to generate the `DESeqDataSet` by loading in the readcounts, as a matrix, the colData (`sample_info`), and the `design = ~ condition`. This effectively creates our `DESeq.ds` object that will be implemented down the line. I then removed genes without reads and saw the number of genes decreased from 59251 to 37309 (see below). We can also note that there are now fewer features stored within the DESeq.ds object. 


```{r DESeq, warning=FALSE, echo=FALSE}
DESeq.ds <- DESeqDataSetFromMatrix(countData = as.matrix(readcounts), colData = sample_info, design = ~ condition)

# Create the DESeq object
DESeq.ds <- DESeqDataSetFromMatrix(countData = as.matrix(readcounts),
                                   colData = sample_info,
                                   design = ~ condition)


#Remove genes with no reads
cat("Number of Genes Before:", dim(DESeq.ds)[1])
keep_genes <- rowSums(counts(DESeq.ds)) > 0
DESeq.ds <- DESeq.ds[ keep_genes, ]
cat("\nNumber of Genes After:", dim(DESeq.ds)[1])
```


### VII. Normalizing for sequencing depth and RNA composition differences

Now, normalization procedures for sequencing depth and RNA composition differences can be undertaken. The `estimateSizeFactors()` function is used for sequencing depth normalization and adds the size factors to the DESeq.ds object. Normalization can be visualized in log2(read counts) boxplots as is seen in Figure 3.

```{r fig3, fig.cap = "**Figure 3:** *Size Factor Normalization*", fig.align = "center"}
# Calculate size factors and add them to object
DESeq.ds <- estimateSizeFactors(DESeq.ds)
# Transform the normalized read counts to bring them onto similar scales
par(mfrow=c(1,2)) # to plot the two box plots next to each other
# Boxplot of non-normalized
boxplot(log2(counts(DESeq.ds) +1), notch=TRUE,
        main = "Non-normalized read count",
        ylab ="log2(read counts)", cex = .6, las = 2)
# Boxplot of size-factor normalized values
boxplot(log2(counts(DESeq.ds, normalized=TRUE) +1), notch=TRUE,
        main = "Size-factor-normalized read count",
        ylab ="log2(read counts)", cex = .6, las = 2)
```


### VIII. Accounting for Heteroskedasticity and Large Dynamic Range

We can then further process the data. First a pair of healthy and a pair of diseased individuals are visualized by comparing their log normalized counts against one another, (refer to Figure 4) wherein each dot is one gene, and we can note that the points fan out towards the lower left corner. This means that lower read counts correlate worse between replicates. This means that the standard deviation of the expression levels likely depends on the mean. 

```{r fig4, fig.cap = "**Figure 4:** *Healthy vs. Diseased Pairs*", fig.align = "center"}
## non-normalized read counts plus pseudocount
log.counts <- log2(counts(DESeq.ds, normalized = FALSE) + 1)

## instead of creating a new object, we could assign the values to a distinct matrix 
## within the DESeq.ds object
assay(DESeq.ds, "log.counts") <- log2(counts(DESeq.ds, normalized = FALSE) + 1)
## normalized read counts
assay(DESeq.ds, "log.norm.counts") <- log2(counts(DESeq.ds, normalized=TRUE) + 1)
par(mfrow=c(1,2))
DESeq.ds[, c("healthy_66","healthy_67")] %>%
  assay(.,  "log.norm.counts") %>%
  plot(., cex=.1, main = "Healthy #66 vs. Healthy #67")
DESeq.ds[, c("diseased_74","diseased_75")] %>%
  assay(.,  "log.norm.counts") %>%
  plot(., cex=.1, main = "Diseased #74 vs Diseased #75")
```

This can be better visualized through a `meanSdPlot` (see Figure 5) where the red line shows the running median estimator and it should be horizontal to indicate that there is no variance-mean dependence. As we can observe in the plot, we see that the data exhibits heteroskedasticity (i.e. there is some variance-mean dependence for genes with low read counts). In order to continue with the analysis, as many tools assume homoskedastic data, we must rectify this. 

```{r fig5, fig.cap = "**Figure 5:** *meanSdPlot*", fig.align = "center"}
#BiocManager::install("vsn")
## generate the base meanSdPlot using sequencing depth normalized log2(read counts) ## set up plotting frame
par(mfrow=c(1,1))
## generate the plot
msd_plot <- vsn::meanSdPlot(assay(DESeq.ds, "log.norm.counts"), ranks=FALSE, # show the data on the original scale
plot = FALSE)
## since vsn::meanSdPlot generates a ggplot2 object, this can be manipulated in the usual ways
msd_plot$gg +
  ggtitle("Sequencing depth normalized log2(read counts)") +
  ylab("standard deviation")
```
To reduce the dependence of the variance on the mean we can use `rlog` and `varianceStabilizingTransformation (vst)`. This yields a much more horizontal line and greatly reduces heteroskedasticity (see Figure 6). The objects created were stored on the disk for future analysis via `save.image()`.


```{r fig6, fig.cap = "**Figure 6:** *meanSdPlot after Correction*", fig.align = "center"}
DESeq.rlog <- rlog(DESeq.ds, blind = TRUE)
rlog.norm.counts <- assay(DESeq.rlog)
## rlog-transformed read counts
msd_plot <- vsn::meanSdPlot(assay(DESeq.rlog), ranks=FALSE, plot = FALSE)
msd_plot$gg + ggtitle("Following rlog transformation") +
  coord_cartesian(ylim = c(0,3))
#save.image(file = "~/Desktop/RNA_data.RData")

```
At the end of this procedure, we have expression values that are adjusted for differences in sequencing depth, differences in RNA composition, heteroskedasticity, and large dynamic range. 

### IX. Performing Differential Gene Expression Analysis

First, I made sure that my control condition (i.e. healthy) would be used as the baseline expression condition within the condition factor. I then began on running the DE analysis by first normalizing for differences in sequencing depth and abundance per sample, using gene-wise dispersion estimates across all samples, and fitting a negative binomial GLM and computing the Wald statistic for each gene through the following command `DESeq.ds %<>% DESeq()`. This makes the DESeq object have more entries in rowData. 

```{r DGE, results = "hide", message=FALSE, echo=FALSE}
#FILE_DSD="~/Desktop/RNA_data.RData"
#load(FILE_DSD)
DESeq.ds$condition #baseline check, make sure control in right place
design(DESeq.ds)
DESeq.ds %<>% DESeq()
DESeq.ds
rowData(DESeq.ds) %>% colnames
```

Now, we can adjust for multiple hypothesis testing with independent filtering using. First, I visualized the raw distribution of p-values (see Figure 7) yielded in the rowData of the DESeq object under `WaldPvalue_condition_healthy_vs_diseased`. 

```{r fig7, fig.cap = "**Figure 7:** *Raw p-values for Healthy vs Diseased*", fig.align = "center"}
rowData(DESeq.ds)$WaldPvalue_condition_healthy_vs_diseased %>%
    hist(breaks=19, main="Raw p-values for Healthy vs Diseased")
```

This can then be filtered using an alpha cutoff of 0.05 with `independentFiltering` to find the optimal expression cutoff to maximize the absolute number of genes that pass through the adjusted p-value threshold. After normalization we see a reduction in the outlier terms and a more even distribution.

```{r fig8, fig.cap = "**Figure 8:** *Adjusted p-values for Healthy vs Diseased*", fig.align = "center"}
DGE.results <- results(DESeq.ds, independentFiltering = TRUE, alpha = 0.05)
DGE.results$padj %>%
    hist(breaks=19, main="Adjusted p-values for Healthy vs Diseased")
```

Shrinkage is performed on the logFC estimates for lowly and noisily expressed genes towards zero, thus reducing their importance for any subsequent  analyses downstream. 

```{r shrinkage, results = "hide", message=FALSE}
#BiocManager::install("apeglm")
DGE.results <- lfcShrink(DESeq.ds, coef=2, type="apeglm")
# Use coef = 2 because second coefficient of resultsNames(DESeq.ds) is condition_healthy_vs_diseased so expression of the genes will be based on these conditions
```


Now, I can sort my DGE.results to obtain some of the top hits with the lowest padj values. We can see by looking at the first 6 genes, some of them are relevant to our study. 

```{r top_degs, echo=FALSE}
DGE.results.sorted <- DGE.results %>% `[`(order(.$padj),)
head(DGE.results.sorted)
```

Figure 9 shows the Mitochondrial Nuclear Retrograde Regulator 1 (CHCHD2), the X-inactive specific transcript (XIST), and ITGA8 which is important in cytoskeletal organization and cellular adhesion were all found the be relevant in the Corsi et al. paper that this data was downloaded from (further analysis to be done in the Results section). 

```{r fig9, fig.cap = "**Figure 9:** *plotCounts for Differentially Expressed Genes*", fig.align = "center"}
par(mfrow=c(1,3))
plotCounts(DESeq.ds, gene="CHCHD2", normalized = TRUE, xlab="")
plotCounts(DESeq.ds, gene="XIST", normalized = TRUE, xlab="")
plotCounts(DESeq.ds, gene="ITGA8", normalized = TRUE, xlab="")
```

Now, a Heatmap can be created to show differential expression for numerous genes at once. In Figure 10, the darker red color shows higher gene expression values whilst the lighter colors show lower gene expression values which are sorted by the p-value. 

```{r fig10, fig.cap = "**Figure 10:** *Heatmap (No Scaling)*", fig.align = "center"}
# identify genes with the desired adjusted p-value cut-off
DGEgenes <- rownames(subset(DGE.results.sorted, padj < 0.05)) # extract rlog-transformed values into a matrix
rlog.dge <- DESeq.rlog[DGEgenes,] %>% assay
# heatmap of DEG sorted by p.adjust
pheatmap(rlog.dge, scale="none",
         show_rownames=FALSE, main="DGE (no scaling)",
         color=colorRampPalette(RColorBrewer::brewer.pal(n=7, name="Reds"))(100)
)
```


In Figure 11 the red color shows high expression values while the blue color shows low expression values with white acting as the median. These values are row normalized (z-score). The intensity of the color indicates gene expression level where each row represents a gene and each column a sample.

```{r fig11, fig.cap = "**Figure 11:** *Heatmap of DGE(row-based z-score)*", fig.align = "center"}
pheatmap(rlog.dge, scale="row",
         show_rownames=FALSE, main="DGE (row-based z-score)")
```

Now, an MA plot can be made to get a global view of the differential genes (Figure 11). Each blue point is a gene that passes the significance threshold (padj < 0.05). Since the y-axis shows the log 2 full change between healthy vs. diseased expression, we can note that as we peruse up or down the y-axis we will see genes that are more differentially expressed between the two. We can also see from the results that there are more differentially expressed genes as the mean normalized counts increase (i.e. more strongly expressed genes). 

```{r fig12, fig.cap = "**Figure 12:** *MA plot*", fig.align = "center"}
plotMA(DGE.results, alpha=0.05,
      main="Test: p.adj.value < 0.05", ylim = c(-8,8))
```

We can also make a volcano plot which also serves to provide a visual representation of the differential expression analysis results. We see the log2 full change on the x axis and the -log(p) values on the y axis. This means that the values in the top right and top left of the plot are of most interest as they exhibit a higher fold change and low p value, making them differentially expressed genes of interest. 

```{r fig13, fig.cap = "**Figure 13:** *Volcano Plot*", fig.align = "center"}

vp1 <- EnhancedVolcano(DGE.results,
                       lab=rownames(DGE.results),
                      x='log2FoldChange', y='padj',
                      pCutoff=0.05,
                      title="Healthy / Diseased")
print(vp1)
```

Now, PCA can be performed. This was done by implementing the `plotPCA` function and grouping by `condition`, I also made sure to take the log base 2 (e.g. rlog) of DESeq and set `blind` to `FALSE` as downstream analysis needs to be undertaken [7]. The results of PCA can be interpreted as each point is a sample, we see that 88% of the variance is due to PC1 and it accounts for most of the variation while 10% of the variance is due to PC2, more on this in the Results section.

```{r fig14, fig.cap = "**Figure 14:** *PCA*", fig.align = "center"}
plotPCA(rlog(DESeq.ds, blind = FALSE), intgroup=c("condition"))
```


Finally, GSEA must be performed. To do this, I will be implementing ClusterProfiler's `enrichGO` function. This was done by running DESeq2 analysis and extracting differentially expressed genes subject to padj < 0.05 and a two fold change in effect size. I kept the default p and q value cutoffs of 0.01 and 0.05, respectively.

The GO enrichments were done for all categories: Biological Process (BP), Molecular Function (MF) and Cellular Component (CC). 

```{r Initialize_ClusterProfiler, message=FALSE, results = 'hide', echo=FALSE}
# Load the required libraries
library(clusterProfiler)
library(org.Hs.eg.db) # or the appropriate organism database

# Run DESeq2 analysis and extract differentially expressed genes
DESeq.ds <- DESeq(DESeq.ds)
DGE.results <- results(DESeq.ds, independentFiltering = TRUE, alpha = 0.05)
num_genes <- length(rownames(subset(DGE.results, padj < 0.05 & abs(log2FoldChange) >= 1.0))) # 1.0 for twofold
cat("Total Number of Differentially Expressed Genes with Padj < 0.05 and Two-Fold Change:\n", num_genes, "\n")
DGE.genes <- rownames(subset(DGE.results, padj < 0.05 & abs(log2FoldChange) >= 2.0)) # 1.0 for twofold
cat("Subset of Genes for GO Enrichment:\n", length(DGE.genes))
#head(DGE.genes)
# Convert differentially expressed genes to a vector
gene.vector <- row.names(DGE.results) %in% DGE.genes %>% as.integer #can be sorted
names(gene.vector) <- row.names(DGE.results) #can be sorted
```

```{r enrichGO, echo=FALSE}
go_enrichment_BP <- enrichGO(gene = names(which(gene.vector == 1)), 
                             'org.Hs.eg.db', 
                             keyType = "SYMBOL", 
                             ont = "BP", 
                             pvalueCutoff = 0.01,
                             qvalueCutoff = 0.05)
cat("Top 6 enrichment pathways for BP\n")
head(go_enrichment_BP@result$Description)
cat("\n")
go_enrichment_CC <- enrichGO(gene = names(which(gene.vector == 1)), 
                             'org.Hs.eg.db', 
                             keyType = "SYMBOL", 
                             ont = "CC", 
                             pvalueCutoff = 0.01,
                             qvalueCutoff = 0.05)
cat("Top 6 enrichment pathways for CC\n")
head(go_enrichment_CC@result$Description)
cat("\n")

go_enrichment_MF <- enrichGO(gene = names(which(gene.vector == 1)), 
                             'org.Hs.eg.db', 
                             keyType = "SYMBOL", 
                             ont = "MF", 
                             pvalueCutoff = 0.01,
                             qvalueCutoff = 0.05)
cat("Top 6 enrichment pathways for MF\n")
head(go_enrichment_MF@result$Description)
cat("\n")

```

# Discussion

Throughout the duration of the project, I faced several challenges. First, when trying to use the ENA browser to download the files, I found that they only contained one file for each sample, which did not make sense due to the paired nature of the data. Apparently, this was due to the fact that the data was in an “interleaved” format, meaning that it was derived using paired-end (as was reported by the depositors) but only contains one file that has both forward and reverse reads. To circumvent this, `fastq-dump`, along with the parameter `--split-files` was used instead to generate the proper paired end data as two separate `.fastq` files. Another issue I found was also when using the ENA browser, I was unable to figure out which of my samples were diseased (A79V mutated) and which were healthy (isogenic control). To get around this issue, I used the SRA Run Selector from NCBI instead. Finally, the last issue I faced was in the fact that the number of differentially expressed genes I found after exclusively using a padj < 0.05 and no fold change cutoff was found to be 11039. After using padj < 0.05 and a two fold change, the number was still quite high at 4154. Finally after implementing a padj < 0.05 and four fold change, I was able to subset the number of Genes to 1371 for GO enrichment. However, the number of differentially expressed genes is still found to be 4154 which could just be due to a very strong effect resulting from the A79V mutation. 

### Table Summarizing Key Data Sets Generated

*Refer to the data_processing file in Github within `RMD_Documents` for how each of these data sets were downloaded and stored, the datasets can be accessed within the `data` folder in Github*

| Data Set | Description  |
|----------|----------|
|readcounts.txt | A subset of featureCounts, gives out reads for each individual gene | 
|DGE_Table.txt | Extraction of all found Differentially Expressed Genes |
|BP_enrichment.txt | Results of BP GO enrichment|
|CC_enrichment.txt| Results of CC GO enrichment |
|MF_enrichment.txt | Results of MF GO enrichment|


# References

[1] D. M. Holtzman, J. C. Morris, and A. M. Goate, “Alzheimer’s disease: The challenge of the second century,” Science Translational Medicine, vol. 3, no. 77, 2011. 

[2] R. Delabio, L. Rasmussen, I. Mizumoto, G.-A. Viani, E. Chen, J. Villares, I.-B. Costa, G. Turecki, S. A. Linde, M. C. Smith, and S.-L. Payão, “PSEN1 and PSEN2 gene expression in alzheimer's disease brain: A new approach,” Journal of Alzheimer's Disease, vol. 42, no. 3, pp. 757–760, 2014. 

[3] H.-M. Lanoiselée, G. Nicolas, D. Wallon, A. Rovelet-Lecrux, M. Lacour, S. Rousseau, A.-C. Richard, F. Pasquier, A. Rollin-Sillaire, O. Martinaud, M. Quillard-Muraine, V. de la Sayette, C. Boutoleau-Bretonniere, F. Etcharry-Bouyx, V. Chauviré, M. Sarazin, I. le Ber, S. Epelbaum, T. Jonveaux, O. Rouaud, M. Ceccaldi, O. Félician, O. Godefroy, M. Formaglio, B. Croisile, S. Auriacombe, L. Chamard, J.-L. Vincent, M. Sauvée, C. Marelli-Tosi, A. Gabelle, C. Ozsancak, J. Pariente, C. Paquet, D. Hannequin, and D. Campion, “App, PSEN1, and PSEN2 mutations in early-onset alzheimer disease: A genetic screening study of familial and sporadic cases,” PLOS Medicine, vol. 14, no. 3, 2017. 

[4] G. I. Corsi, V. P. Gadekar, H. Haukedal, N. T. Doncheva, C. Anthon, S. Ambardar, D. Palakodeti, P. Hyttel, K. Freude, S. E. Seemann, and J. Gorodkin, “The transcriptomic landscape of neurons carrying PSEN1 mutations reveals changes in extracellular matrix components and non-coding gene expression,” Neurobiology of Disease, vol. 178, p. 105980, 2023. 

[5] L. Granat, R. J. Hunt, and J. M. Bateman, “Mitochondrial retrograde signalling in neurological disease,” Philosophical Transactions of the Royal Society B: Biological Sciences, vol. 375, no. 1801, p. 20190415, 2020. 

[6] V. P. Bajic, M. Essack, L. Zivkovic, A. Stewart, S. Zafirovic, V. B. Bajic, T. Gojobori, E. Isenovic, and B. Spremo-Potparevic, “The X files: ‘The mystery of x chromosome instability in alzheimer’s disease,’” Frontiers in Genetics, vol. 10, 2020. 

[7] “Rlog: Apply a 'regularized log' transformation,” RDocumentation. [Online]. Available: https://www.rdocumentation.org/packages/DESeq2/versions/1.12.3/topics/rlog. [Accessed: 25-Apr-2023]. 









